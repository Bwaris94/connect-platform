-- C --
    <section class="suite">
      <h1>platform</h1>
      <dl>
        <section class="suite">
          <h1>core.base</h1>
          <dl>
            <section class="suite">
              <h1>Pin</h1>
              <dl>
                <section class="suite">
                  <h1>.connect() and .disconnect()</h1>
                  <dl>
                    <dt>should connect and disconnect two pins.</dt>
                    <dd><pre><code>let a = new Pin();
let b = new Pin();
a.connect(b);
assert(a.connected(b));
assert(b.connected(a));
b.disconnect(a);
assert(!a.connected(b));
assert(!b.connected(a));</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.reset()</h1>
                  <dl>
                    <dt>should reset pin&#x27;s state.</dt>
                    <dd><pre><code>let a = new Pin();
a._activate();
assert(a.activated);
a.reset();
assert(!a.activated);</code></pre></dd>
                    <dt>should be subscribable.</dt>
                    <dd><pre><code>done =&#x3E; {
      let a = new Pin();
      a.subscribe(PinEvents.reset, ()=&#x3E;{done()});
      a.reset();
    }</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>InputPin &#x26; OutputPin</h1>
              <dl>
                <section class="suite">
                  <h1>.send() and .receive()</h1>
                  <dl>
                    <dt>should be able to transfer data and activate the inputs.</dt>
                    <dd><pre><code>let i1 = new InputPin();
let i2 = new InputPin();
let o = new OutputPin().connect(i1).connect(i2);
o.send(&#x27;HOLA!&#x27;);
assert.equal(i1.data, i2.data);
assert.equal(i1.data, &#x27;HOLA!&#x27;);
assert(i2.activated);</code></pre></dd>
                    <dt>should be subscribable.</dt>
                    <dd><pre><code>done =&#x3E; {
      let i = new InputPin();
      let o = new OutputPin().connect(i);
      i.subscribe(IOPinEvents.receive, data =&#x3E; {
        assert.equal(data, &#x27;HOLA!&#x27;);
        done();
      });
      o.send(&#x27;HOLA!&#x27;);
    }</code></pre></dd>
                    <dt>should only transfer the first time.</dt>
                    <dd><pre><code>let i = new InputPin();
let o1 = new OutputPin().connect(i);
let o2 = new OutputPin().connect(i);
o1.send(&#x27;Hellow&#x27;);
o2.send(&#x27;World&#x27;);
o2.send(&#x27;XXX&#x27;);
assert.equal(i.data, &#x27;Hellow&#x27;);
assert.equal(o2.data, &#x27;World&#x27;);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.connect()</h1>
                  <dl>
                    <dt>should only accept proper pin type.</dt>
                    <dd><pre><code>let i1 = new InputPin();
let i2 = new InputPin();
let o1 = new OutputPin();
let o2 = new OutputPin();
assert.throws(()=&#x3E; {
  i1.connect(i2);
}, IncompatiblePins);
assert.throws(()=&#x3E; {
  o1.connect(o2);
}, IncompatiblePins);
o1.connect(i1);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.reset()</h1>
                  <dl>
                    <dt>should reset transferred data state as well.</dt>
                    <dd><pre><code>let i = new InputPin();
let o = new OutputPin().connect(i);
o.send(2);
assert.equal(i.data, 2);
assert.equal(o.data, 2);
i.reset();
o.reset();
assert(!i.data);
assert(!o.data);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>ControlPin and ControllerPin</h1>
              <dl>
                <section class="suite">
                  <h1>.activate()</h1>
                  <dl>
                    <dt>should activate connected ControlPins.</dt>
                    <dd><pre><code>let a = new ControllerPin();
let b1 = new ControlPin().connect(a);
let b2 = new ControlPin().connect(a);
assert(!b1.activated);
assert(!b2.activated);
a.activate();
assert(b1.activated);
assert(b2.activated);</code></pre></dd>
                    <dt>should activate a ControlPin if all its ControllerPins are activated.</dt>
                    <dd><pre><code>let a1 = new ControllerPin();
let a2 = new ControllerPin();
let b = new ControlPin().connect(a1).connect(a2);
assert(!b.activated);
a1.activate();
assert(!b.activated);
a2.activate();
assert(b.activated);</code></pre></dd>
                    <dt>should be subcribable.</dt>
                    <dd><pre><code>done =&#x3E; {
      let a = new ControllerPin();
      let b = new ControlPin().connect(a);
      b.subscribe(PinEvents.activate, ()=&#x3E; {done()});
      a.activate();
    }</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.connect()</h1>
                  <dl>
                    <dt>should connect to proper pin type only.</dt>
                    <dd><pre><code>let a1 = new ControllerPin();
let a2 = new ControllerPin();
let b1 = new ControlPin();
let b2 = new ControlPin();
assert.throws(() =&#x3E; {
  a1.connect(a2);
}, IncompatiblePinTypes);
assert.throws(() =&#x3E; {
  b1.connect(b2);
}, IncompatiblePinTypes);
a1.connect(b1);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>Node</h1>
              <dl>
                <dt>should run the run() method when activated and send results to output pins.</dt>
                <dd><pre><code>done =&#x3E; {
    let n = new class extends Node {
      run(inputs, output) {
        output(&#x27;res&#x27;, inputs.a * 2);
      }
    }({inputs: [&#x27;a&#x27;], outputs:[&#x27;res&#x27;]});
    n.pins.out.res.subscribe(IOPinEvents.send, data =&#x3E; {
      assert.equal(data, 6);
      done();
    });
    n.pins.in.a.receive(3);
  }</code></pre></dd>
                <dt>should run the run() method when activated and activate proper controller pins.</dt>
                <dd><pre><code>done =&#x3E; {
    let n = new class extends Node {
      run(_, __, control) {
        control(&#x27;x&#x27;);
      }
    }({inputs: [&#x27;a&#x27;], controlOutputs: [&#x27;x&#x27;]});
    n.pins.controlOut.x.subscribe(PinEvents.activate, () =&#x3E; {
      done();
    });
    n.pins.in.a.receive(&#x27;stuff.&#x27;);
  }</code></pre></dd>
                <dt>should stop run() after ouput is given.</dt>
                <dd><pre><code>done =&#x3E; {
    let life = 2;
    let n1 = new class extends Node {
      run(inputs, output) {
        life += 1;
        output(&#x27;res&#x27;, inputs.a);
        life += 1;
      }
    }({inputs: [&#x27;a&#x27;], outputs:[&#x27;res&#x27;]});
    n1.pins.out.res.subscribe(IOPinEvents.send, data =&#x3E; {
      assert.equal(life, 3);
      done();
    });
    n1.pins.in.a.receive(&#x27;well ...&#x27;);
  }</code></pre></dd>
                <dt>should stop the run() when control called.</dt>
                <dd><pre><code>done =&#x3E; {
    let life = 4;
    let n = new class extends Node {
      run(_, __, control) {
        life += 1;
        control(&#x27;x&#x27;);
        life += 1;
      }
    }({inputs: [&#x27;a&#x27;], controlOutputs: [&#x27;x&#x27;]});
    n.pins.controlOut.x.subscribe(PinEvents.activate, () =&#x3E; {
      assert.equal(life, 5);
      done();
    });
    n.pins.in.a.receive(&#x27;stuff.&#x27;);
  }</code></pre></dd>
                <section class="suite">
                  <h1>constructor()</h1>
                  <dl>
                    <dt>should generate input pins from signature.</dt>
                    <dd><pre><code>let n = new Node({
  inputs: [&#x27;a&#x27;, &#x27;b&#x27;],
});
assert(n.pins.in.a instanceof InputPin);
assert(n.pins.in.b instanceof InputPin);</code></pre></dd>
                    <dt>should generate output pins from signature.</dt>
                    <dd><pre><code>let n = new Node({
  outputs: [&#x27;a&#x27;, &#x27;b&#x27;],
});
assert(n.pins.out.a instanceof OutputPin);
assert(n.pins.out.b instanceof OutputPin);</code></pre></dd>
                    <dt>should generate control output pins from signature.</dt>
                    <dd><pre><code>let n = new Node({
  controlOutputs: [&#x27;a&#x27;, &#x27;b&#x27;]
});
assert(n.pins.controlOut.a instanceof ControllerPin);
assert(n.pins.controlOut.b instanceof ControllerPin);</code></pre></dd>
                    <dt>should generate a control pin.</dt>
                    <dd><pre><code>let n = new Node();
assert(n.pins.control instanceof ControlPin);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.activated</h1>
                  <dl>
                    <dt>should be true when all inputs are activated.</dt>
                    <dd><pre><code>let n = new Node({inputs: [&#x27;a&#x27;, &#x27;b&#x27;]});
assert(!n.activated);
n.pins.in.a.receive(2);
n.pins.in.b.receive(3);
assert(n.activated);</code></pre></dd>
                    <dt>should check controllers connected to control pin.</dt>
                    <dd><pre><code>let n = new Node({inputs: [&#x27;a&#x27;]});
let c1 = new ControllerPin().connect(n.pins.control);
let c2 = new ControllerPin().connect(n.pins.control);
n.pins.in.a.receive();
assert(!n.activated);
c1.activate();
assert(!n.activated);
c2.activate();
assert(n.activated);</code></pre></dd>
                    <dt>should be subscribable.</dt>
                    <dd><pre><code>done =&#x3E; {
      let n = new Node({inputs: [&#x27;a&#x27;]});
      n.subscribe(NodeEvents.activate, ()=&#x3E;{done()});
      n.pins.in.a.receive();
    }</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.reset()</h1>
                  <dl>
                    <dt>should reset node&#x27;s state.</dt>
                    <dd><pre><code>let n = new Node({inputs:[&#x27;a&#x27;]});
n.pins.in.a.receive(2);
assert(n.activated);
n.reset();
assert(!n.activated);</code></pre></dd>
                    <dt>should also reset state of all its pins.</dt>
                    <dd><pre><code>let n = new class extends Node {
  run(inputs, output) {
    output(&#x27;res&#x27;, inputs.a * 2);
  }
}({inputs: [&#x27;a&#x27;], outputs:[&#x27;res&#x27;]});
return new Promise(resolve=&#x3E; {
  n.pins.in.a.receive(4);
  n.pins.out.res.subscribe(IOPinEvents.send, ()=&#x3E; {
    assert(n.pins.in.a.activated);
    assert(n.pins.out.res.activated);
    n.reset();
    assert(!n.pins.in.a.activated);
    assert(!n.pins.out.res.activated);
    assert(!n.pins.in.a.data);
    resolve();
  });
});</code></pre></dd>
                    <dt>should be subscribable.</dt>
                    <dd><pre><code>done =&#x3E; {
      let n = new Node();
      n.subscribe(NodeEvents.reset, ()=&#x3E;{done()});
      n.reset();
    }</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.checkActivate()</h1>
                  <dl>
                    <dt>should activate a node when it can be activated.</dt>
                    <dd><pre><code>let n = new Node();
n.checkActivate();
assert(n.activated);
let n2 = new Node({inputs: [&#x27;a&#x27;]});
n2.checkActivate();
assert(!n2.activated);
let n3 = new Node();
let c = new ControllerPin().connect(n3.pins.control);
n3.checkActivate();
assert(!n3.activated);</code></pre></dd>
                    <dt>should result in node&#x27;s running as well.</dt>
                    <dd><pre><code>done =&#x3E; {
      let n = new class extends Node {
        run(){done();}
      }();
      n.checkActivate();
    }</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>core</h1>
          <dl>
            <section class="suite">
              <h1>registry</h1>
              <dl>
                <section class="suite">
                  <h1>.register()</h1>
                  <dl>
                    <dt>should register a node class or factory with given path.</dt>
                    <dd><pre><code>registry.register({path: &#x27;X&#x27;}, base.node.Node);
registry.register({path: &#x27;Y&#x27;}, () =&#x3E; new base.node.Node());
assert(registry.registered(&#x27;X&#x27;));
assert(registry.registered(&#x27;Y&#x27;));</code></pre></dd>
                    <dt>should override with subsequent registration.</dt>
                    <dd><pre><code>class A extends base.node.Node{};
class B extends base.node.Node{};
registry.register({path: &#x27;X&#x27;}, A);
assert(registry.instance(&#x27;X&#x27;) instanceof A);
registry.register({path: &#x27;X&#x27;}, B);
assert(registry.instance(&#x27;X&#x27;) instanceof B);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.instance()</h1>
                  <dl>
                    <dt>should return an instance of a registered class or factory.</dt>
                    <dd><pre><code>class A extends base.node.Node{};
class B extends base.node.Node{};
registry.register({path: &#x27;X&#x27;}, A);
registry.register({path: &#x27;Y&#x27;}, () =&#x3E; new B());
assert(registry.instance(&#x27;X&#x27;) instanceof A);
assert(registry.instance(&#x27;Y&#x27;) instanceof B);</code></pre></dd>
                    <dt>should throw proper error when given path is not registered.</dt>
                    <dd><pre><code>assert.throws(() =&#x3E; {
  registry.instance(&#x27;XX/123456&#x27;);
}, UnregisteredPath);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.signature()</h1>
                  <dl>
                    <dt>should return the signature of a registered node class or factory.</dt>
                    <dd><pre><code>registry.register({path: &#x27;X&#x27;, inputs: [&#x27;a&#x27;]}, base.node.Node);
assert.equal(registry.signature(&#x27;X&#x27;).inputs[0], &#x27;a&#x27;);</code></pre></dd>
                    <dt>should throw proper error when given path is not registered.</dt>
                    <dd><pre><code>assert.throws(() =&#x3E; {
  registry.signature(&#x27;XX/123456&#x27;);
}, UnregisteredPath);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>node()</h1>
              <dl>
                <dt>should generate a node class.</dt>
                <dd><pre><code>let N = node({}, ()=&#x3E;{});
let n = new N();
assert(n instanceof base.node.Node);</code></pre></dd>
                <dt>should register the node class if path is given.</dt>
                <dd><pre><code>node({path:&#x27;X&#x27;}, ()=&#x3E;{});
assert(registry.registered(&#x27;X&#x27;));</code></pre></dd>
                <dt>should return a node that has the same signature.</dt>
                <dd><pre><code>let N = node({inputs:[&#x27;a&#x27;, &#x27;b&#x27;], outputs: [&#x27;c&#x27;]}, ()=&#x3E;{});
let n = new N();
assert(n.pins.in.a);
assert(n.pins.in.b);
assert(n.pins.out.c);</code></pre></dd>
                <dt>should return a node that runs the given function.</dt>
                <dd><pre><code>done =&#x3E; {
    let N = node({}, ()=&#x3E;{done();});
    let n = new N();
    n.checkActivate();
  }</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>callable()</h1>
              <dl>
                <dt>should return a callable that runs the given node.</dt>
                <dd><pre><code>done =&#x3E; {
    class N extends base.node.Node {
      constructor(){
        super({
          inputs: [&#x27;a&#x27;],
          outputs: [&#x27;res&#x27;],
        });
      }
      run(inputs, output){
        output(&#x27;res&#x27;, inputs.a + 5);
      }
    };
    let f = callable(N);
    f({a: 4}).then(result =&#x3E; {
      assert.equal(result.output, &#x27;res&#x27;);
      assert.equal(result.data, 9);
      done();
    });
  }</code></pre></dd>
                <dt>should throw proper error if required input not provided.</dt>
                <dd><pre><code>done =&#x3E; {
    class N extends base.node.Node {
      constructor(){super({inputs: [&#x27;a&#x27;, &#x27;b&#x27;]});}
    }
    let f = callable(N);
    f({b: &#x27;hellow&#x27;}).catch(error =&#x3E; {
      assert(error instanceof InputMissing);
      done();
    });
  }</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>Expression</h1>
              <dl>
                <dt>should be a node that evaluates a given expression.</dt>
                <dd><pre><code>done =&#x3E; {
    let e = new Expression(&#x22;[a + 2, a - 2]&#x22;, [&#x27;a&#x27;]);
    e.pins.result.subscribe(IOPinEvents.send, res =&#x3E; {
      assert.equal(res[0], 7);
      assert.equal(res[1], 3);
      done();
    });
    e.pins.in.a.receive(5);
  }</code></pre></dd>
                <dt>should naturally work like a raw value when no input is required.</dt>
                <dd><pre><code>done =&#x3E; {
    let e = new Expression(&#x22;2 * 3&#x22;);
    e.pins.result.subscribe(IOPinEvents.send, res =&#x3E; {
      assert.equal(res, 6);
      done();
    });
    e.checkActivate();
  }</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>Switch</h1>
              <dl>
                <dt>should have a controller pin for each given case.</dt>
                <dd><pre><code>let s = new Switch([&#x27;2 + 3&#x27;, &#x27;1.5 * 2&#x27;]);
assert(s.pins.cases[&#x27;2 + 3&#x27;] instanceof base.control.ControllerPin);
assert(s.pins.cases[&#x27;1.5 * 2&#x27;] instanceof base.control.ControllerPin);</code></pre></dd>
                <dt>should activate proper control pin based on given input</dt>
                <dd><pre><code>done =&#x3E; {
    let s = new Switch([&#x27;4.5 * 2&#x27;, &#x27;9 / 2&#x27;]);
    let c1 = new base.control.ControlPin()
                  .connect(s.pins.cases[&#x27;4.5 * 2&#x27;])
                  .subscribe(base.pin.PinEvents.activate, () =&#x3E; {done()});
    let c2 = new base.control.ControlPin()
                  .connect(s.pins.cases[&#x27;9 / 2&#x27;])
                  .subscribe(base.pin.PinEvents.activate, () =&#x3E; {done(&#x27;wrong!&#x27;)});
    s.pins.target.receive(9);
  }</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>Call</h1>
              <dl>
                <dt>should call a node registered by a path in registry.</dt>
                <dd><pre><code>done =&#x3E; {
    node({ path: &#x27;X&#x27; }, () =&#x3E; {done()});
    let c = new Call(&#x27;X&#x27;);
    c.checkActivate();
  }</code></pre></dd>
                <dt>should have the same signature as the class it is going to call.</dt>
                <dd><pre><code>node({ path: &#x27;X&#x27;, inputs: [&#x27;a&#x27;]}, ()=&#x3E;{});
let c = new Call(&#x27;X&#x27;);
assert(c.pins.in.a);</code></pre></dd>
                <dt>should return the same value as the class it is going to call.</dt>
                <dd><pre><code>done =&#x3E; {
    node({ path: &#x27;X&#x27;, inputs: [&#x27;a&#x27;], outputs: [&#x27;b&#x27;]},
        (inputs, output) =&#x3E; { output(&#x27;b&#x27;, inputs.a * 10)});
    let c = new Call(&#x27;X&#x27;);
    c.pins.out.b.subscribe(IOPinEvents.send, data =&#x3E; {
      assert.equal(data, 75);
      done();
    });
    c.pins.in.a.receive(7.5);
  }</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>*** fibonacci test ***</h1>
              <dl>
                <dt>should demonstrate the awesomeness of platform by calculating fibonacci function.</dt>
                <dd><pre><code>done =&#x3E; {
    let Fib = node({
      path: &#x27;tests/fib&#x27;,
      inputs: [&#x27;n&#x27;],
      outputs: [&#x27;res&#x27;],
    }, (inputs, output) =&#x3E; {
      let i = new Expression(&#x27;n &#x3C; 3&#x27;, [&#x27;n&#x27;]);
      let iv = new Expression(&#x27;1&#x27;);
      let is = new Switch([&#x27;false&#x27;, &#x27;true&#x27;]);
      let nm1 = new Expression(&#x27;n - 1&#x27;, [&#x27;n&#x27;]);
      let nm2 = new Expression(&#x27;n - 2&#x27;, [&#x27;n&#x27;]);
      let p = new Expression(&#x27;a + b&#x27;, [&#x27;a&#x27;, &#x27;b&#x27;]);
      let c1 = new Call(&#x27;tests/fib&#x27;);
      let c2 = new Call(&#x27;tests/fib&#x27;);
      let _in = new OutputPin();
      let _out = new InputPin();
      _in
        .connect(i.pins.in.n)
        .connect(nm1.pins.in.n)
        .connect(nm2.pins.in.n);
      i.pins.result.connect(is.pins.target);
      is.pins.cases[&#x27;true&#x27;].connect(iv.pins.control);
      is.pins.cases[&#x27;false&#x27;]
              .connect(nm1.pins.control)
              .connect(nm2.pins.control);
      nm1.pins.result.connect(c1.pins.in.n);
      nm2.pins.result.connect(c2.pins.in.n);
      c1.pins.out.res.connect(p.pins.in.a);
      c2.pins.out.res.connect(p.pins.in.b);
      _out
        .connect(p.pins.result)
        .connect(iv.pins.result);
      _out.subscribe(IOPinEvents.receive, res =&#x3E; output(&#x27;res&#x27;, res));
      _in.send(inputs.n);
    });
    let fib = callable(Fib);
    fib({n : 7}).then(res =&#x3E; {
      assert.equal(res.data, 13);
      done();
    });
  }</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
        <section class="suite">
          <h1>builder</h1>
          <dl>
            <section class="suite">
              <h1>Composition</h1>
              <dl>
                <section class="suite">
                  <h1>.addInput()</h1>
                  <dl>
                    <dt>should add an input pin.</dt>
                    <dd><pre><code>let c = new Composition();
c.addInput(&#x27;a&#x27;);
assert(c.inputs.a instanceof core.pins.OutputPin);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.addConfig()</h1>
                  <dl>
                    <dt>should add an config pin.</dt>
                    <dd><pre><code>let c = new Composition();
c.addConfig(&#x27;a&#x27;);
assert(c.configs.a instanceof core.pins.OutputPin);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.addOutput()</h1>
                  <dl>
                    <dt>should add an output pin.</dt>
                    <dd><pre><code>let c = new Composition();
c.addOutput(&#x27;a&#x27;);
assert(c.outputs.a instanceof core.pins.InputPin);</code></pre></dd>
                    <dt>should add a control output when requested to.</dt>
                    <dd><pre><code>let c = new Composition();
c.addOutput(&#x27;a&#x27;, true);
assert(c.outputs.a instanceof core.pins.ControlPin);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.addCall()</h1>
                  <dl>
                    <dt>should add a call node.</dt>
                    <dd><pre><code>let c = new Composition();
c.addCall(&#x27;x&#x27;, &#x27;/hellow/world&#x27;);
assert(c.nodes.x instanceof core.Call);</code></pre></dd>
                    <dt>which has the correct path.</dt>
                    <dd><pre><code>let c = new Composition();
c.addCall(&#x27;x&#x27;, &#x27;/hellow/world&#x27;);
assert.equal(c.nodes.x.path, &#x27;/hellow/world&#x27;);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.addSwitch</h1>
                  <dl>
                    <dt>should add a switch node.</dt>
                    <dd><pre><code>let c = new Composition();
c.addSwitch(&#x27;x&#x27;, []);
assert(c.nodes.x instanceof core.Switch);</code></pre></dd>
                    <dt>should has the correct cases.</dt>
                    <dd><pre><code>let c = new Composition();
c.addSwitch(&#x27;x&#x27;, [&#x27;2&#x27;]);
assert(c.nodes.x.pins.cases[&#x27;2&#x27;]);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.addExpr()</h1>
                  <dl>
                    <dt>should add an expression.</dt>
                    <dd><pre><code>let c = new Composition();
c.addExpr(&#x27;x&#x27;, [], &#x27;null&#x27;);
assert(c.nodes.x instanceof core.Expression);</code></pre></dd>
                    <dt>which has the correct inputs.</dt>
                    <dd><pre><code>let c = new Composition();
c.addExpr(&#x27;x&#x27;, [&#x27;a&#x27;], &#x27;a * 2&#x27;);
assert(c.nodes.x.pins.in.a);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.addValue()</h1>
                  <dl>
                    <dt>should add an expression without inputs.</dt>
                    <dd><pre><code>let c = new Composition();
c.addValue(&#x27;x&#x27;, &#x27;22&#x27;);
assert(c.nodes.x instanceof core.Expression);
assert.equal(Object.keys(c.nodes.x.pins.in).length, 0);</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.run()</h1>
                  <dl>
                    <dt>should be able to run given composition of nodes for inputs {a : 2, b : 3}.</dt>
                    <dd><pre><code>done =&#x3E; {
      c.outputs.cool.subscribe(core.events.io.receive, data =&#x3E; {
        assert.equal(data, &#x27;ok its cool.&#x27;);
        done();
      });
      c.reset();
      c.start({a: 2, b : 3});
    }</code></pre></dd>
                    <dt>and also giving correct input for {a : 1, b : 4}.</dt>
                    <dd><pre><code>done =&#x3E; {
      c.outputs.not_cool.subscribe(core.events.pin.activate, data =&#x3E; {
        done();
      });
      c.reset();
      c.start({a: 1, b : 4});
    }</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
            <section class="suite">
              <h1>Recipe</h1>
              <dl>
                <section class="suite">
                  <h1>.add()</h1>
                  <dl>
                    <dt>should add instructions.</dt>
                    <dd><pre><code>let r = new Recipe();
r.add(() =&#x3E; {});</code></pre></dd>
                  </dl>
                </section>
                <section class="suite">
                  <h1>.apply()</h1>
                  <dl>
                    <dt>should apply given instructions on given composition.</dt>
                    <dd><pre><code>done =&#x3E; {
      let r = new Recipe();
      let c = new Composition();
      r.add(_c =&#x3E; {
        assert.equal(_c, c);
        done();
      });
      r.apply(c);
    }</code></pre></dd>
                    <dt>should apply given instructions in given order.</dt>
                    <dd><pre><code>let r = new Recipe();
let _ = &#x22;&#x22;;
r.add(() =&#x3E; _ += &#x27;a&#x27;);
r.add(() =&#x3E; _ += &#x27;b&#x27;);
r.add(() =&#x3E; _ += &#x27;c&#x27;);
r.apply(null);
assert.equal(_, &#x27;abc&#x27;);</code></pre></dd>
                  </dl>
                </section>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
